#!/home/gabriel/pythonenvs/v3.5/bin/python

import numpy as np

def create_dataset(n_samples=10, n_features=3,
                        perc_lin_comb=2, perc_repeated=0, n_groups=2,
                        avg_sample_dist=1.0, shift=0.0, scale=1.0, perc_feat_lin_dep=25,
                        shuffle=True,feat_dist=0):

    # feat_dist =  Feature distribution
    ## 0: interleave standard normal and uniform values
    ## [ x, y]: provide amount of attributes for each type (x and y >= 0)

    if feat_dist == 0:
        unifor_attr = int(n_features/2)
        standa_attr = n_features - unifor_attr
    print("uniform features: "+unifor_attr.__str__())
    print("standard features: "+standa_attr.__str__())

    # Harcoded seed
    seed = 563456
    value_limit = 1000000

    # Random numbers generator
    generator = np.random.RandomState(seed)

    # Initialize dataset 
    X = np.zeros((n_samples, n_features))

    # Generate standard columns
    for i in range(1,standa_attr):
        # Create a random number for mean and stdev
        mean = (generator.random_integers(low=(-1)*value_limit, high=value_limit, size=(1)))[0]

        # Generate stdev as a percentage of mean (betwee 10% and 50%)
        stdev = (generator.random_integers(low=1, high=5, size=(1)))[0]*0.1*abs(mean)
        print("mean: "+mean.__str__())
        print("stdev: "+stdev.__str__())

    # Generate a matrix of n_samples X n_columns with random samples from the “standard normal” distribution
    #m1 = generator.randn(n_samples,n_columns)

    # Generate a matrix of n_samples X n_columns with random samples from a uniform distribution over [0, 1)
    #m2 = generator.rand(n_samples,n_columns)
    ## Round floats to two decimals
    #m2.round(decimals=2)


    # Generate a matrix of n_samples X n_columns with random samples from a uniform distribution over [-10, 1)
    #m3 = generator.random_integers(low=-10, high=10, size=(n_samples,n_columns))



    # Populating only the first "n_columns" columns of the matrix
    #X[:, :n_columns] = m1



    ## Generating redundant atributes 
    # Creating matrix B which are basically columns of random numbers multplied by 2 and substracted 1
    #B = 2 * generator.rand(n_informative, n_redundant) - 1

    # Redundant values are generated by "dot / escalar" multiplying B (random numbers) by the informative values (linear combination?)
    #redundant_column = np.dot(X[:, :n_informative], B)

    # Adding redundant column to X
    #X[:, n_informative:n_informative + n_redundant] = redundant_column


create_dataset(n_samples=100, n_features=5,
                        perc_lin_comb=2, perc_repeated=0, n_groups=2,
                        avg_sample_dist=1.0, shift=0.0, scale=1.0, perc_feat_lin_dep=25,
                        shuffle=True,feat_dist=0)

